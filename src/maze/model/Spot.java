package maze.model;

import java.util.Objects;


/**
 * This class represents a spot in a maze that knows its coordinate in the maze
 * and its distance to the maze's goal.
 *
 * Each spot in the maze represents a "state": either a wall or a hall.
 * If it is a hall, it may be empty (undiscovered), visited (discovered and
 * abandoned) or path (discovered and actively being explored).
 *
 * @author Robert C. Duvall
 * @author Shannon Pollard
 */
public class Spot implements Comparable<Spot> {
    // Possible states of spots that make up a maze
    // impassable wall
    public static final int WALL = 0;
    // hall is either current spot being explored or spot determined to be in computed path
    public static final int PATH = 1;
    // basic hall spot
    public static final int EMPTY = 2;
    // hall spot that was visited and discarded
    public static final int VISITED = 3;

    private final int myX;
    private final int myY;
    private final int myDistance;
    private int myState;


    /**
     * Create a Spot with given coordinates, state, and distance to maze's goal.
     */
    public Spot (int x, int y, int state,  int distance) {
        myX = x;
        myY = y;
        myDistance = distance;
        myState = state;
    }

    /**
     * Compare this Spot to the given Spot based on their distance to maze's goal.
     */
    @Override
    public int compareTo (Spot other) {
        return Integer.compare(myDistance, other.myDistance);
    }

    /**
     * Returns this Spot's x-coordinate.
     */
    public int getX () {
        return myX;
    }

    /**
     * Returns this Spot's y-coordinate.
     */
    public int getY () {
        return myY;
    }

    /**
     * Returns this Spot's distance to maze's goal.
     */
    public int getDistanceToGoal () {
        return myDistance;
    }

    /**
     * Returns this Spot's state.
     */
    public int getState () {
        return myState;
    }

    /**
     * Turns this Spot into a "path" Spot, only if it is not a wall.
     */
    public void markAsPath () {
        if (myState != WALL) {
            myState = PATH;
        }
    }

    /**
     * Turns this Spot into a "visited" Spot, only if it is not a wall.
     */
    public void markAsVisited () {
        if (myState != WALL) {
            myState = VISITED;
        }
    }

    /**
     * Turns this Spot into an "empty" Spot, only if it is not a wall.
     */
    public void markAsEmpty () {
        if (myState != WALL) {
            myState = EMPTY;
        }
    }

    /**
     * @see Object#toString()
     */
    @Override
    public String toString () {
        String state = switch (myState) {
            case 0 -> "WALL";
            case 1 -> "PATH";
            case 2 -> "EMPTY";
            case 3 -> "VISITED";
            default -> "";
        };
        return String.format("(%d, %d): %s", myX, myY, state);
    }

    /*
     * Remaining code was generated by IntelliJ so this class can be used in collections (like Lists and Maps).
     */
    /**
     * @see Object#equals(Object)
     */
    @Override
    public boolean equals (Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Spot spot = (Spot) o;
        return myX == spot.myX && myY == spot.myY && myDistance == spot.myDistance && myState == spot.myState;
    }

    /**
     * @see Object#hashCode()
     */
    @Override
    public int hashCode () {
        return Objects.hash(myX, myY, myDistance, myState);
    }
}
